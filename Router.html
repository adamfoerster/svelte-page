{#if page}
<svelte:component this={page.child} {...page.props} /> {/if}

<script>
  import page from 'page'

  /** Creates a route callback with the specified data */
  const getRouteMiddleware = (routePath, routes) => {
    if (routes[routePath].constructor !== Object) {
      routes[routePath] = { component: routes[routePath] }
    }

    const { data = {}, loader } = routes[routePath]
    let hasPreloaded = false

    const loadPreloads = () => {
      const { preload } = routes[routePath]
      setTimeout(() =>
        preload.forEach(preloadRoute => {
          const loader = routes[preloadRoute].loader
          if (typeof loader === 'function') {
            loader().then(({ default: component }) => {
              routes[preloadRoute].component = component
            })
          }
        }),
      )
      hasPreloaded = true
    }

    return (ctx, next) => {
      const {
        components,
        params,
        state: { path, ...state },
      } = ctx

      const { component, preload } = routes[routePath]

      /** Remove pathregexp path match */
      delete params[0]
      const routeData = Object.assign({}, data, state, { params })

      /** If no component present and */
      if (!component) {
        /** If there's a loader function, load it */
        if (typeof loader === 'function') {
          loader().then(({ default: component }) => {
            components.push({ component, data: routeData })
            if (preload && !hasPreloaded) {
              loadPreloads()
            }
            next()
          })
        } else {
          throw new Error(
            '[svelte-router] No component for route "' + routePath + '"',
          )
        }
        return
      }

      components.push({ component, data: routeData })
      if (preload && !hasPreloaded) {
        loadPreloads()
      }
      next()
    }
  }

  const getSveltedHierarchy = Router => ctx => {
    const { components } = ctx
    const props = {}

    /** Data needs to always be an object or else nesting won't work */
    components.reduce((prev, { component, data = {} }) => {
      data.page = null
      prev.page = {
        child: component,
        props: data,
      }

      return prev.page.props
    }, props)

    if (Router.store) {
      Router.store.fire('router:navigation', ctx)
    }
    Router.set(props)
  }

  export default {
    setup(Router) {
      Router.go = page.show
      Router.back = page.back
      Router.getCurrentPath = () => page.current
    },
    data() {
      return {
        page: null,
        strict: true,
        hashbang: true,
      }
    },
    onstate({ previous, current }) {
      if (!previous) {
        const { routes, strict, hashbang } = current

        /** Set up the component hierarchy */
        page('*', (ctx, next) => {
          ctx.components = []
          next()
        })

        /** Generate page routes */
        Object.keys(routes).forEach(path =>
          page(path, getRouteMiddleware(path, routes)),
        )

        /** Translate component array into svelte state */
        page('*', getSveltedHierarchy(this))

        /** Allow trailing slash */
        page.strict(strict)

        /** Start the router */
        page.start({ hashbang })
      }
    },
  }
</script>
